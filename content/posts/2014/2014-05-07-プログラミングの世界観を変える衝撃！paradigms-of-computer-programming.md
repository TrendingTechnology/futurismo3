---
author: admin
categories:
- MOOC
- 書評
date: 2014-05-07T10:36:00+00:00
dsq_thread_id:
- 3.7034665e+09
excerpt: EdxでParadigms of Computer Programmingという講座を受けたまとめ
follow:
- follow
index:
- index
page_layout:
- def
pdrp_attributionLocation:
- end
pvc_views:
- 8195
side:
- def
sub:
- def
tags:
- edX
title: プログラミングの世界観を変える衝撃！Paradigms of Computer Programmingで震えるほどの知的感動を体験した
type: post
url: /archives/=2427
---

<img alt="" src="https://futurismo.biz/wp-content/uploads/CPMCP.jpg" width="560"/>  </p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">はじめに</h2>
<div class="outline-text-2" id="text-1">
<p> MOOCのEdxでParadigms of Computer Programmingという講座を受けた。 </p>
<ul class="org-ul">
<li><a href="https://www.edx.org/course/louvainx/louvainx-louv1-01x-paradigms-computer-1203#.U2oLTxMu2IM">LouvainX: Louv1.01x: Paradigms of Computer Programming | edX</a> </li>
</ul>
<p>  <iframe width="560" height="315" src="//www.youtube.com/embed/D1q2dCNGDOE" frameborder="0" allowfullscreen></iframe>  </p>
<p> 感動というものを頭に走る電撃と定義するならば、 このCourseは自分にとって、まちがいなく最高の感動だった。 </p>
<p> [toc] </p>
</p></div>
</p></div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">内容</h2>
<div class="outline-text-2" id="text-2"> </div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">感動的な講義の展開</h3>
<div class="outline-text-3" id="text-2-1">
<p> プログラム言語のパラダイムやコンセプトが紹介される。 </p>
<p> 5つのパラダイムが紹介される。 </p>
<ul class="org-ul">
<li>Functional Programming(関数型プログラミング) </li>
<li>Object-Oriented Programming(オブジェクト指向プログラミング) </li>
<li>Deterministic Dataflow Programming(決定性データフロープログラミング) </li>
<li>Multi-Agent Dataflow Programming(マルチエージェントデータフロープログラミング) </li>
<li>Active Object Programming(アクティブオブジェクトプログラミング) </li>
</ul>
<p> 感動すべきは、その講義の展開だ。 </p>
<p> はじめに、すべてのBaseになる関数型パラダイムからスタート。 </p>
<p> そして、関数型パラダイムに、 State(状態)という概念を追加することで、 オブジェクト指向パラダイムに発展させる！ </p>
<p> また、関数型パラダイムに  Concurrency(並行性)、Thread(スレッド)という概念をを追加することで、 決定性データフローパラダイムに発展させる！ </p>
<p> そして、決定性データフローパラダイムに Port(ポート)という概念をを追加することで、 マルチエージェントデータフローパラダイムに発展させる！ </p>
<p> 最後に、オブジェクト指向パラダイムとマルチエージェントデータフローパラダイムを 融合させることで、アクティブオブジェクト指向パラダイムへ発展させる！ </p>
<p> 新しいパラダイムやコンセプトが紹介されるごとに、 価値観を覆す感動が自分の頭の中で電撃としてピリピリ走った。 めくるめく感動体験の連続である。 </p>
<p> こんな体験はそうめったにできるものではない。スゴい！ </p>
</p></div>
</p></div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">情熱的なビーターバンロイさん</h3>
<div class="outline-text-3" id="text-2-2">
<p> レクチャーをするビーターバンロイさんの語り口がとても情熱的だ。 </p>
<p> 語り口にも感動した。重要な概念になるたびに、 声の音程と強さがあがり、情熱的に語りかけてくる。感動に拍車をかける。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Oz(マルチパラダイム言語)と参考書について</h3>
<div class="outline-text-3" id="text-2-3">
<p> Ozというマルチパラダイム言語を利用する。 </p>
<ul class="org-ul">
<li><a href="https://futurismo.biz/archives/2271">マルチパラダイム言語Ozの開発環境MozartをインストールしてHelloWorldするまで | Futurismo</a> </li>
</ul>
<p> 個人的には、MozartがEmacsをベースにしているところがとてもよかった。Emacs最高！ </p>
<ul class="org-ul">
<li><a href="https://futurismo.biz/archives/2399">Mozartをemacsclientから起動する方法のメモ | Futurismo</a> </li>
</ul>
<p> しかし、Ozの文法がわからない・・。 </p>
<p> 情報元やサンプルコードが少なくて、文法を調べるのに苦労した。 概念的にわかっていてもその実装するための文法がわからず時間かかったり。 loopを書くのに2時間つかったり。参考書とforumでサンプルコード漁りまくった。 </p>
</p></div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Oz勉強リンク</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li><a href="https://e-p-i.github.io/tutorial_of_oz/index.html">Tutorial of Oz</a> </li>
<li><a href="https://dream.inf.ed.ac.uk/computing/installed/mozart/doc/opi/index.html">The Oz Programming Interface</a> </li>
<li><a href="https://www.eecs.ucf.edu/~leavens/ComS541Fall06/running_oz.shtml#">Running Oz</a> </li>
</ul></div>
</p></div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">参考書</h4>
<div class="outline-text-4" id="text-2-3-2">
<div class='amazlink-box' style='text-align:left;padding-bottom:20px;font-size:small;/zoom: 1;overflow: hidden;'>
<div class='amazlink-list' style='clear: both;'>
<div class='amazlink-image' style='float:left;margin:0px 12px 1px 0px;'><a href='https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5%E3%83%BB%E6%8A%80%E6%B3%95%E3%83%BB%E3%83%A2%E3%83%87%E3%83%AB-Architect-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B06-Architects%E2%80%99Archive-CLASSIC/dp/4798113468%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798113468' target='_blank' rel='nofollow'><img src='https://ecx.images-amazon.com/images/I/51iXhiKTamL._SL160_.jpg' style='border: none;' /></a></div>
<div class='amazlink-info' style='height:160; margin-bottom: 10px'>
<div class='amazlink-name' style='margin-bottom:10px;line-height:120%'><a href='https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5%E3%83%BB%E6%8A%80%E6%B3%95%E3%83%BB%E3%83%A2%E3%83%87%E3%83%AB-Architect-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B06-Architects%E2%80%99Archive-CLASSIC/dp/4798113468%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798113468' rel='nofollow' target='_blank'>コンピュータプログラミングの概念・技法・モデル(IT Architect' Archiveクラシックモダン・コンピューティング6) (IT Architects’Archive CLASSIC MODER)</a></div>
<div class='amazlink-powered' style='font-size:80%;margin-top:5px;line-height:120%'>posted with <a href='https://amazlink.keizoku.com/' title='アマゾンアフィリエイトリンク作成ツール' target='_blank'>amazlink</a> at 14.05.07</div>
<div class='amazlink-detail'>セイフ・ハリディ</div>
<div class='amazlink-sub-info' style='float: left;'>
<div class='amazlink-link' style='margin-top: 5px'><img src='https://amazlink.fuyu.gs/icon_amazon.png' width='18'><a href='https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E6%A6%82%E5%BF%B5%E3%83%BB%E6%8A%80%E6%B3%95%E3%83%BB%E3%83%A2%E3%83%87%E3%83%AB-Architect-Archive%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B06-Architects%E2%80%99Archive-CLASSIC/dp/4798113468%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4798113468' rel='nofollow' target='_blank'>Amazon</a> <img src='https://amazlink.fuyu.gs/icon_rakuten.gif' width='18'><a href='https://hb.afl.rakuten.co.jp/hgc/g00q0724.n763w947.g00q0724.n763x2b4/archives/c=http%3A%2F%2Fbooks.rakuten.co.jp%2Frb%2F5079035%2F&#038;m=http%3A%2F%2Fm.rakuten.co.jp%2Frms%2Fmsv%2FItem%3Fn%3D5079035%26surl%3Dbook' rel='nofollow' target='_blank'>楽天</a></div>
</div>
</div>
</div>
</div>
<p> 分厚くて重い。。900ページある。しかし、これがないと辛い。実はEnglishが一番難しい言語。 </p>
<p> 通称、CTM本、CTMCP本、ガウディ本というらしい。 </p>
<ul class="org-ul">
<li><a href="https://www.info.ucl.ac.be/~pvr/book.html">Concepts, Techniques, and Models of Computer Programming</a> </li>
</ul></div>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">感想</h2>
<div class="outline-text-2" id="text-3"> </div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">モチベーション</h3>
<div class="outline-text-3" id="text-3-1">
<p> 講座のなかでは、以下のような利点を強調してモチベーションをあげようとしている。 </p>
<ul class="org-ul">
<li>いくつものプログラミング言語がある。全てを学ぶことは不可能。 </li>
<li>プログラミング言語はパラダイムで分類できる。 </li>
<li>パラダイム、そこから導出れるコンセプトを抑えることで、多くの言語を理解できる！ </li>
</ul>
<p> なるほど、利にかなっている。 </p>
<p> 今は、オブジェクト指向が全盛だが、その天下もいつまで続くかは分からない。 </p>
<p> 技術が進めばマルチコアや並列処理に対応するために、それに適した言語が必要になるかもしれない。 HTMLなんかは宣言的プログラミングの典型で、オブジェクト指向ではどうにもならない。 </p>
<p> プロフェッショナルなプログラマを目指すのならば、 オブジェクト指向だけでなくて、他の考え方も知っておきたいところだ。 </p>
<p> また高校生のころにこんな本を読んで、とても感激を受けた。 </p>
<div class='amazlink-box' style='text-align:left;padding-bottom:20px;font-size:small;/zoom: 1;overflow: hidden;'>
<div class='amazlink-list' style='clear: both;'>
<div class='amazlink-image' style='float:left;margin:0px 12px 1px 0px;'><a href='https://www.amazon.co.jp/%E5%B0%8F%E8%AB%96%E6%96%87%E3%82%92%E5%AD%A6%E3%81%B6%E2%80%95%E7%9F%A5%E3%81%AE%E6%A7%8B%E7%AF%89%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB-%E9%95%B7%E5%B0%BE-%E9%81%94%E4%B9%9F/dp/463407110X%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D463407110X' target='_blank' rel='nofollow'><img src='https://ecx.images-amazon.com/images/I/41RWWEBXB7L._SL160_.jpg' style='border: none;' /></a></div>
<div class='amazlink-info' style='height:160; margin-bottom: 10px'>
<div class='amazlink-name' style='margin-bottom:10px;line-height:120%'><a href='https://www.amazon.co.jp/%E5%B0%8F%E8%AB%96%E6%96%87%E3%82%92%E5%AD%A6%E3%81%B6%E2%80%95%E7%9F%A5%E3%81%AE%E6%A7%8B%E7%AF%89%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB-%E9%95%B7%E5%B0%BE-%E9%81%94%E4%B9%9F/dp/463407110X%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D463407110X' rel='nofollow' target='_blank'>小論文を学ぶ―知の構築のために</a></div>
<div class='amazlink-powered' style='font-size:80%;margin-top:5px;line-height:120%'>posted with <a href='https://amazlink.keizoku.com/' title='アマゾンアフィリエイトリンク作成ツール' target='_blank'>amazlink</a> at 14.05.07</div>
<div class='amazlink-detail'>長尾 達也</div>
<div class='amazlink-sub-info' style='float: left;'>
<div class='amazlink-link' style='margin-top: 5px'><img src='https://amazlink.fuyu.gs/icon_amazon.png' width='18'><a href='https://www.amazon.co.jp/%E5%B0%8F%E8%AB%96%E6%96%87%E3%82%92%E5%AD%A6%E3%81%B6%E2%80%95%E7%9F%A5%E3%81%AE%E6%A7%8B%E7%AF%89%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB-%E9%95%B7%E5%B0%BE-%E9%81%94%E4%B9%9F/dp/463407110X%3FSubscriptionId%3DAKIAJDINZW45GEGLXQQQ%26tag%3Dsleephacker-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D463407110X' rel='nofollow' target='_blank'>Amazon</a> <img src='https://amazlink.fuyu.gs/icon_rakuten.gif' width='18'><a href='https://hb.afl.rakuten.co.jp/hgc/g00q0724.n763w947.g00q0724.n763x2b4/archives/c=http%3A%2F%2Fbooks.rakuten.co.jp%2Frb%2F1365994%2F&#038;m=http%3A%2F%2Fm.rakuten.co.jp%2Frms%2Fmsv%2FItem%3Fn%3D1365994%26surl%3Dbook' rel='nofollow' target='_blank'>楽天</a></div>
</div>
</div>
</div>
</div>
<p> パラダイムを学び、そしてその考えに触れることで自分の価値観が揺るがされる。 新たな世界が見えるようになる。そんな知的興奮をパラダイムは与えてくれる。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">実際は、、</h3>
<div class="outline-text-3" id="text-3-2">
<p> 講座は2月からはじまったのだが、他のことが忙しくてスケジュールどおりには進められなかった。 </p>
<p> なので、4末に講座が終了したあと、5月のGWの休みに集中して一気に勉強した。 </p>
<p> AssignmentやExamは締切り後に解いたりして、点数にはならず。それが残念。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">プログラミング言語の分類学</h3>
<div class="outline-text-3" id="text-3-3">
<p> プログラミングパラダイムを分類したポスターが以下のサイトからダウンロードできる。 </p>
<p> <a href="https://www.info.ucl.ac.be/~pvr/paradigms.html">- Classification of the principal programming paradigms</a> </p>
<p> 今まで3つのパラダイムしかしらなかった。 </p>
<ul class="org-ul">
<li>Declarative Programming(宣言的プログラミング) </li>
<li>Procedural programming(手続き型プログラミング) </li>
<li>Object-Oriented Programming(オブジェクト指向プログラミング) </li>
</ul>
<p> このポスターを眺めてみると、プログラミングの世界は広大であり、 自分は視野が狭かった、ほんの片鱗しか見えていなかったと思った。 </p>
<p> そして、この講座で紹介されなかったパラダイムもまだまだたくさんあることに驚いた。 もっともっと、いろんな言語やパラダイムに触れたいと、強く思った。 </p>
<p> ちなみに、最後にオススメ言語が紹介される。 よい言語は、広く様々なパラダイムをカバーしてていること。 その意味で、ScalaとErlangがオススメ、 C++とJavaもややマルチパラダイムだけどちょっとレガシー、だそうだ。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Coursereで紹介されたプログラムパラダイムのメモ</h2>
<div class="outline-text-2" id="text-4">
<p> メモをとりながら、動画を見ていたのでそのメモ。 </p>
<p> 今まで、あまりメモはとらなかった。満員電車で動画を見ることが多かったので。 今回はGWに集中して取り組めたので、メモをとることはよいことだと思った。 </p>
<p> 以下、引用がほとんどのメモだけれども、内容が間違っているかもしれないので注意。 </p>
<p> これはEmacs org-modeで階層的にメモをとった。 これからも、今回触れられなかったパラダイムを追加していき、 パラダイムツリーを生涯にわたって進化させていきたい。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">プログラミングパラダイムとは</h2>
<div class="outline-text-2" id="text-5">
<p> プログラミングパラダイムとは、プログラミングの分類方法、スコープ、見方。 </p>
<p> なにかを定義しているようでなにもいっていない・・・詳しくはwikipedia参照。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%91%E3%83%A9%E3%83%80%E3%82%A4%E3%83%A0">プログラミングパラダイム - Wikipedia</a> </li>
</ul></div>
</p></div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Base Concepts</h2>
<div class="outline-text-2" id="text-6"> </div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Valiables</h3>
<div class="outline-text-3" id="text-6-1">
<p> 変数の構成要素は以下の2つ。 </p>
<ul class="org-ul">
<li>識別子(Identifier) </li>
<li>格納域実体(Store entity) </li>
</ul></div>
<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">Identifires and Store Entity</h4>
<div class="outline-text-4" id="text-6-1-1">
<p> x = 1 ということはどういうことかを説明する概念。 </p>
<p> 数学的な写像関係で x = 1 を説明しようとしている。{ X -> x1=1 }みたいな感じ。 x1がメモリ上の実際の(束縛された)値で、Xがそれを指し示す識別子。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2">environments</h4>
<div class="outline-text-4" id="text-6-1-2">
<p> 識別子と変数の写像関係を環境という。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">State</h3>
<div class="outline-text-3" id="text-6-2">
<p> State(状態）とは、必要とされる計算の途中結果を含む、値の時系列。 (sequence of values calculated progressively, which contains the intermediate results of a computation) </p>
<p> 状態の導入によって、プログラムに時間の概念を与える。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Declarative Programming</h2>
<div class="outline-text-2" id="text-7">
<p> 宣言型プログラミング。 </p>
<p> 第1の意味は、 処理方法ではなく対象の性質などを宣言することでプログラミングするパラダイム。 第2の意味は、 純粋関数型プログラミング、論理プログラミング、制約プログラミングの総称。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">宣言型プログラミング - Wikipedia</a> </li>
<li>Imperative Programingの対になる概念。 "Function without State" </li>
<li>Imperative vs Declaretive is also Stateful vs Stateless </li>
</ul>
<p> HTMLはStateless、Declarative Programming language. 状態はクッキーを導入してしばしば実現する。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Functional Programmming</h2>
<div class="outline-text-2" id="text-8"> </div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Impliclite(declarative) State</h3>
<div class="outline-text-3" id="text-8-1">
<p> 暗黙的状態。宣言的状態ともいう。 </p>
<ul class="org-ul">
<li>関数の実行結果が値をもつ </li>
<li>同じ入力には必ず同じ出力を返す。 </li>
<li>Explicite Stateとの対概念。 </li>
<li>参照透明性。 </li>
</ul></div>
</p></div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Higher-order programming</h3>
<div class="outline-text-3" id="text-8-2">
<p> 高階プログラミング。procedure valueをサポートしている言語でのプログラミング技術。 関数を引数としてわたす能力。 </p>
<p> Rubyではlambda, procなど。C言語には関数ポインタがある。C言語は2階。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Recursion</h3>
<div class="outline-text-3" id="text-8-3">
<p> 再帰的プログラミング。 </p>
</p></div>
<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1">accumulater</h4>
<div class="outline-text-4" id="text-8-3-1">
<p> C++の、numericライブラリ(accumuulateなど)で利用されている。 </p>
<p> スタックのサイズが均一なことが特徴的。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2">tail-recursion</h4>
<div class="outline-text-4" id="text-8-3-2">
<p> 末尾再帰。 </p>
<p> その中にただ1つの再帰呼び出しがあり、 かつその呼び出しが手続き本体の最後にあるもの。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-8-3-3" class="outline-4">
<h4 id="sec-8-3-3">invariant programming</h4>
<div class="outline-text-4" id="text-8-3-3">
<p> 不変式プログラミング。再帰的に呼ばれる度に、数学的に真になる式。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E6%9D%A1%E4%BB%B6">不変条件 - Wikipedia</a> </li>
</ul></div>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Imperative Programming</h2>
<div class="outline-text-2" id="text-9">
<p> 命令型プログラミング。 計算をプログラム状態を変化させる文の列で記述するパラダイム。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">命令型プログラミング - Wikipedia</a> </li>
</ul>
<p> Imperative Programmingとは、Function paradigmにCellの概念を加えたもの。 </p>
<ul class="org-ul">
<li>Declarative Programingの対になる概念。 Imperative vs Declaretive is also Stateful vs Stateless </li>
</ul>
<div class="org-src-container">
<pre class="src src-language">Imperative programming = Function paradigm + Cell
</pre>
</p></div>
<ul class="org-ul">
<li>実行するたびに、内部の状態によって結果がことなる。 </li>
<li>手続き型と同義のこともある。(Procedural programming) </li>
</ul>
<p> 手順やチェックリストはプログラムではないが、 命令型プログラミングのスタイルに似たコンセプトである。 それらのステップが命令であり、実世界が状態を保持している。 </p>
<ul class="org-ul">
<li>械語は命令から構成される </li>
</ul>
<p> 低レベルから見た場合、 プログラムの状態はメモリの内容によって定義され、文としては機械語の命令が相当する。 </p>
</p></div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Explicite State</h3>
<div class="outline-text-3" id="text-9-1">
<p> 明示的状態。 </p>
<ul class="org-ul">
<li>生存期間が2度以上の手続的呼び出しに渡るような一つの状態。 </li>
<li>関数の実行の中に値をもつ。 </li>
<li>手続きの引数に現れないもの。 </li>
</ul>
<p> 同様なことを関数型パラダイムで実現するためには、仮引数に状態を持たないといけない。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Cell</h3>
<div class="outline-text-3" id="text-9-2">
<p> Explicite State(明示的状態)を表す基本型。二つの構成要素からなる。 </p>
<ul class="org-ul">
<li>名前値(Vaiue) </li>
<li>単一代入格納域への参照(Identifier) </li>
</ul>
<p> Function ParadigmsとImperative Paradigmの違いは、 </p>
<ul class="org-ul">
<li>Function
<ul class="org-ul">
<li>状態変化しない(Immunity) </li>
<li>機能追加時にインタフェースの変更の影響度がおおきい。 </li>
</ul>
</li>
<li>Inperative
<ul class="org-ul">
<li>機能追加時にインタフェースの変更の影響度がない。(モジュール性, モジュールプログラミング） </li>
<li>状態変化する。 </li>
</ul>
</li>
</ul></div>
</p></div>
</p></div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Structured programming</h2>
<div class="outline-text-2" id="text-10">
<p> 構造化プログラミング。 </p>
<p> 構造化プログラミングではプログラミング言語が持つステートメントを 直接使ってプログラムを記述するのではなく、 それらを抽象化したステートメントを持つ仮想機械を想定し、 その仮想機械上でプログラムを記述する。 普通、抽象化は1段階ではなく階層的である。 各階層での実装の詳細は他の階層と隔離されており、 実装の変更の影響はその階層内のみに留まる(Abstract data structures)。 各階層はアプリケーションに近い抽象的な方から土台に向かって順序付けられている。 pこの順序は各階層を設計した時間的な順番とは必ずしも一致しない(Concluding remarks) </p>
<p> <a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">- 構造化プログラミング - Wikipedia</a> </p>
<p> 標準的な制御構造のみを使い、 プログラム全体を段階的に細かな単位に分割して処理を記述していく手法。 </p>
<ul class="org-ul">
<li><a href="https://e-words.jp/w/E6A78BE980A0E58C96E38397E383ADE382B0E383A9E3839FE383B3E382B0.html">構造化プログラミングとは 【 structured programming 】 ： IT用語辞典</a> </li>
</ul>
<p> 「制御の流れ」を構造化しただけであり、 「データ構造」には何の制限や規則も設けていない。 </p>
<p> 「芸術品」から脱却して「工業製品」へ遷移すること、 あるいは、「処理性能重視」から「保守性重視」へ向かったもの。 別の見方をすれば、処理効率を犠牲にして、作りやすさや理解容易性を求めたもの。 </p>
<ul class="org-ul">
<li><a href="https://monoist.atmarkit.co.jp/mn/articles/1009/17/news118.html">構造化プログラミングからオブジェクト指向への進化 - MONOist（モノイスト）</a> </li>
</ul></div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">三つの構造化文</h3>
<div class="outline-text-3" id="text-10-1">
<p> ダイクストラが提唱。 </p>
<ul class="org-ul">
<li>順次 </li>
</ul>
<p> 順接、順構造とも言われる。 プログラムに記された順に、逐次処理を行なっていく。 プログラムの記述とコンピュータの動作経過が一致するプログラム構造である。 </p>
<ul class="org-ul">
<li>反復 </li>
</ul>
<p> 一定の条件が満たされている間処理を繰り返す。 </p>
<ul class="org-ul">
<li>分岐 </li>
</ul>
<p> ある条件が成立するなら処理Aを、そうでなければ処理Bを行なう。 </p>
<p> <a href="https://ja.wikipedia.org/wiki/%E6%A7%8B%E9%80%A0%E5%8C%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">- 構造化プログラミング - Wikipedia</a> </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Object-Oriented Programming</h2>
<div class="outline-text-2" id="text-11">
<p> オブジェクト指向型プログラミング。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">オブジェクト指向プログラミング - Wikipedia</a> </li>
</ul>
<p> CTMCP, Chapter 6,7 </p>
</p></div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Data abstraction</h3>
<div class="outline-text-3" id="text-11-1">
<p> データ抽象。3つの構成要素がある。 </p>
<ul class="org-ul">
<li>Input </li>
<li>Output </li>
<li>Interface </li>
</ul>
<p> データ抽象は内部と外部からなるプログラムかつ、両者がインターフェースを通じてやりとりするもの。 </p>
<p> A data abstraction is a part of a program that has an inside, an outside, and an interface in between The inside is hidden from the outside. </p>
</p></div>
<div id="outline-container-sec-11-1-1" class="outline-4">
<h4 id="sec-11-1-1">Input/Output</h4>
<div class="outline-text-4" id="text-11-1-1">
<p> 内部は外部からは隠蔽されている。-> カプセル化という。 </p>
<p> The inside is hidden from the outside </p>
</p></div>
</p></div>
<div id="outline-container-sec-11-1-2" class="outline-4">
<h4 id="sec-11-1-2">Interface</h4>
<div class="outline-text-4" id="text-11-1-2">
<p> The interface is a set of operations that an be used according to certain rules. </p>
<p> データ抽象には、主に二つの方法がある。 </p>
<ul class="org-ul">
<li>Abstract Data Type(ADT) keeps values and operations separate. </li>
<li>Object groups together value and operations in a single entity. </li>
</ul></div>
</p></div>
<div id="outline-container-sec-11-1-3" class="outline-4">
<h4 id="sec-11-1-3">Encapsulation</h4>
<div class="outline-text-4" id="text-11-1-3">
<p> プログラムと内部と内部をインタフェースで分けること。 </p>
<p> カプセル化のメリットは大規模開発をシンプルにする。 </p>
<ul class="org-ul">
<li>正しさを保証する。 </li>
<li>複雑さを解消する。 </li>
</ul></div>
</p></div>
<div id="outline-container-sec-11-1-4" class="outline-4">
<h4 id="sec-11-1-4">Abstract Data Type</h4>
<div class="outline-text-4" id="text-11-1-4">
<p> 抽象データ型。ADTと略されることも。 </p>
<p> 構造化プログラミングは仮想機械モデルに基づく段階的詳細化法（stepwise refinement）をもたらしたが、 データ構造の変更を行うと変更部分がソースコード中に散在してしまうという弱点があった。 データ抽象の概念はその欠点を補完するものであった </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B">抽象データ型 - Wikipedia</a> </li>
</ul>
<p> An ADT consists of a set of values and  a set of operations. </p>
<ul class="org-ul">
<li>Integer型
<ul class="org-ul">
<li>Value:1,2,3 </li>
<li>Operation:+ </li>
</ul>
</li>
<li>Stack型
<ul class="org-ul">
<li>Value: elemtent </li>
<li>Operation: push, pop, &#x2026; </li>
</ul>
</li>
</ul>
<p> ValueとOperationそれ自体はStateを持たない。 </p>
<p> CTM, p433 </p>
<p> Diference between ADT and Object。Stackをつかった実装の違い。 </p>
<ul class="org-ul">
<li>ADT </li>
</ul>
<div class="org-src-container">
<pre class="src src-oz"><span style="color: #f92672; font-weight: bold;">local</span> Wrap Unwrap <span style="color: #f92672; font-weight: bold;">in</span>
  {NewWrapper Wrap Unwrap}
  <span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">NewStack</span>} {Wrap nil} <span style="color: #f92672; font-weight: bold;">end</span>
  <span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">Push</span> W X} {Wrap X<span style="color: #f92672; font-weight: bold;">|</span>{Unwrap W}} <span style="color: #f92672; font-weight: bold;">end</span>
  <span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">Pop</span> W X} S={Unwrap W} <span style="color: #f92672; font-weight: bold;">in</span> X=S<span style="color: #f92672; font-weight: bold;">.</span>1 {Wrap S<span style="color: #f92672; font-weight: bold;">.</span>2} <span style="color: #f92672; font-weight: bold;">end</span>
  <span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">IsEmpty</span> W} {Unwrap W}<span style="color: #f92672; font-weight: bold;">==</span>nil <span style="color: #f92672; font-weight: bold;">end</span>
<span style="color: #f92672; font-weight: bold;">end</span>
</pre>
</p></div>
<p> この手法はStateful ADTという。 </p>
<p> そして、C言語では、こうやってデータ抽象化を行うことがおおい。 もちろん関数ポインタ配列を使えばC言語でもObjectをつくることができるが、 実際にはそこまでやらない。(面倒) </p>
<ul class="org-ul">
<li>Object </li>
</ul>
<p> オブジェクトでは、データに対する操作はプロシージャ変数として扱われることに注目。 </p>
<div class="org-src-container">
<pre class="src src-oz"><span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">NewStack</span>}
  C={NewCell nil}
  <span style="color: #f92672; font-weight: bold;">proc</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">Push</span> X} C<span style="color: #f92672; font-weight: bold;">:=</span>X<span style="color: #f92672; font-weight: bold;">|@</span>C <span style="color: #f92672; font-weight: bold;">end</span>
  <span style="color: #f92672; font-weight: bold;">proc</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">Pop</span> X} S=<span style="color: #f92672; font-weight: bold;">@</span>C <span style="color: #f92672; font-weight: bold;">in</span> X=S<span style="color: #f92672; font-weight: bold;">.</span>1 C<span style="color: #f92672; font-weight: bold;">:=</span>S<span style="color: #f92672; font-weight: bold;">.</span>2 <span style="color: #f92672; font-weight: bold;">end</span>
  <span style="color: #f92672; font-weight: bold;">fun</span><span style="color: #fd971f;"> </span>{<span style="color: #00ffff;">IsEmpty</span>} <span style="color: #f92672; font-weight: bold;">@</span>C<span style="color: #f92672; font-weight: bold;">==</span>nil <span style="color: #f92672; font-weight: bold;">end</span>
<span style="color: #f92672; font-weight: bold;">in</span>
  stack(push:Push pop:Pop isEmpty:IsEmpty)
<span style="color: #f92672; font-weight: bold;">end</span>
</pre>
</p></div>
<p> オブジェクト指向言語は、 単にObjectをサポートする言語ではなくて、Abstruct Data Typeも強力にサポートしている。 </p>
<p> ObjectとADTの意味がごっちゃにつかわれているのが現実の現状。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">Object</h3>
<div class="outline-text-3" id="text-11-2">
<p> 値と操作をひとつのまとまりとしたもの。以下の構成要素をもつ。 </p>
<ul class="org-ul">
<li>値 ・・・Explicite State(明示的状態) </li>
<li>操作 ・・・Procedural Data Abstruction(手続的データ抽象) </li>
</ul>
<p> 以下の能力を備えている。 </p>
</p></div>
<div id="outline-container-sec-11-2-1" class="outline-4">
<h4 id="sec-11-2-1">Data Abstruction</h4>
<div class="outline-text-4" id="text-11-2-1">
<p> オブジェクトは内部と外部はインタフェースを通じてやりとりされる。 </p>
<p> 内部の明示的状態をAttributes,インタフェースをMethodsという。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-11-2-2" class="outline-4">
<h4 id="sec-11-2-2">Procedure Dispatch</h4>
<div class="outline-text-4" id="text-11-2-2">
<p> オブジェクトは単一なエントリポイントをもつ。(エントリポイント = 呼び出し口) エントリポイントに渡される引数をメッセージという。 </p>
<p> 下の例だと、Counterがエントリポイント。エントリポイントにinc,getメッセージを送る。 </p>
<div class="org-src-container">
<pre class="src src-oz">   {Counter inc}
   {Counter get(X)}
</pre>
</p></div>
<p> エントリポイントから、メッセージに対応するプロシージャが呼びだされる。 </p>
<p> メッセージとプロシシージャはあらかじめDispatch(バンドリング)されている。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-11-2-3" class="outline-4">
<h4 id="sec-11-2-3">Instantiation</h4>
<div class="outline-text-4" id="text-11-2-3">
<p> オブジェクトは一つのメソッドで、 異なる属性をもつ複数のオブジェクトを生成できる。 </p>
<p> この能力をInstantiation(インスタンス化）という。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-11-2-4" class="outline-4">
<h4 id="sec-11-2-4">Classes</h4>
<div class="outline-text-4" id="text-11-2-4">
<p> メソッドと属性を定義する特別なシンタックスをClassという。 </p>
<p> 属性とメソッドはレコードデータ構造によって管理されているだけである！ </p>
<p> Classという概念によって、オブジェクトの"宣言"と"生成(new)"を分離する。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">Polymorphism</h3>
<div class="outline-text-3" id="text-11-3">
<p> <a href="https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0">- ポリモーフィズム - Wikipedia</a> </p>
</p></div>
</p></div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4">Inheritance</h3>
<div class="outline-text-3" id="text-11-4">
<p> 継承。あるオブジェクトが他のオブジェクトの特性を引き継ぐこと。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E7%B6%99%E6%89%BF_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)">継承 (プログラミング) - Wikipedia</a> </li>
</ul></div>
</p></div>
<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5">Exceptions</h3>
<div class="outline-text-3" id="text-11-5">
<p> 例外。プログラムがある処理を実行している途中で、 なんらかの異常が発生した場合に、 現在の処理を中断（中止）して、別の処理を行うこと。 その際に発生した異常のことを例外と呼ぶ </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86">例外処理 - Wikipedia</a> </li>
</ul>
<p> よくある2つの概念。 </p>
<ul class="org-ul">
<li>try  ・・・ 例外ハンドラをもつ例外補足コンテクストを生成。   </li>
<li>raise・・・ もっとも内部の例外補足コンテキストへjampし、そこにある例外ハンドラを起動。 </li>
</ul>
<p> 各コンテキストはスタックで管理され、tryはスタックの１つにmarkerをつける。 raiseはmarkerにジャンプしてmarkerの場所に例外処理のコンテキストを挿入する。 </p>
<p> CTM p93参照。 </p>
<p> 例外をつかわないと、コンテクストごとの結果を検証必要があり、 case文が乱立するうんこコードが出来る。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Concurrenct Programming</h2>
<div class="outline-text-2" id="text-12">
<p> 複数の相互作用を及ぼす計算タスクの（同時）並行的実行をおこなうパラダイム。 </p>
<p> 平行プログラミング。(並列プログラミングではない)。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E8%A8%88%E7%AE%97">並行計算 - Wikipedia</a> </li>
<li><a href="https://ja.wikipedia.org/wiki/%E4%B8%A6%E5%88%97%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0">並列計算 - Wikipedia</a> </li>
</ul>
<p> Multiple progressing activities that exist at the same time Activities that can communicate and synchronize </p>
<ul class="org-ul">
<li>Communicate: information passes from one activity to another </li>
<li>Synchronize: an activity waits for another to perform a specific action </li>
</ul>
<p> 平行プログラミングには3つの代表的なパラダイムがある。 </p>
<ul class="org-ul">
<li>Detarministic Dataflow </li>
<li>Message-passing concurrency(Erlang and Scala actor) </li>
<li>Shared-State concurrency(Java monitors) </li>
</ul>
<p> その他、並列実行の競合をさけるためには、以下ようなパラダイムもある。 </p>
<ul class="org-ul">
<li>Lazy Deterministic Dataflow </li>
<li>Constraint Programming </li>
</ul></div>
</p></div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Detarministic Dataflow Programming</h2>
<div class="outline-text-2" id="text-13">
<p> 決定性データフロープログラミング。 </p>
<p> 関数型パラダイムをべースにしている。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">データフロープログラミング - Wikipedia</a> </li>
</ul>
<p> スレッド処理、時間経過をともなうのにも関わらず、実行結果はつねに一定！ これが、Deterministicと名づけられた所以。 </p>
<p> Deerministic is not Obsarbable. </p>
<p> アイデア自体は70年代に提示されたアイデアのに、今まで忘れ去れれていた。 </p>
<ul class="org-ul">
<li>MultiCore, ManyCore Processing (マルチコア、メニーコア) </li>
<li>Destributed Computing </li>
<li>Concurrent Deployment </li>
<li>BigData Computing </li>
</ul>
<p> 以上のようなキーワードとともに、 21世紀の今こそ注目をあびるべき、次世代プログラミングパラダイム！ （とピーターバンロイさんがいっていた） </p>
<p> CTMCP, Chapter 4 </p>
</p></div>
<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">Detarministic Dataflow</h3>
<div class="outline-text-3" id="text-13-1"> </div>
<div id="outline-container-sec-13-1-1" class="outline-4">
<h4 id="sec-13-1-1">Unbound Value</h4>
<div class="outline-text-4" id="text-13-1-1">
<p> メモリ上に値が存在しないが、宣言された変数。 </p>
<ul class="org-ul">
<li>C/C++では、ゴミ(不定データ)が格納されている。 </li>
<li>Javaは0初期化されている。 </li>
<li>Prologは実行時にエラー終了する。 </li>
<li>Ozは値がbindされるまでまちあわせる。 </li>
</ul></div>
</p></div>
<div id="outline-container-sec-13-1-2" class="outline-4">
<h4 id="sec-13-1-2">DataFlow Value</h4>
<div class="outline-text-4" id="text-13-1-2">
<p> Unbound Valueがbindされるまでプログラムの実行を待ち合わせるような宣言的変数。 </p>
<p> Bindされたときの実行を Dataflow Executionという。 </p>
<p> このデータフロー変数によって、No Race Conditions(非強豪状態)を実現する！ (これがもっともこのパラダイムで大事) </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E7%AB%B6%E5%90%88%E7%8A%B6%E6%85%8B">競合状態 - Wikipedia</a> </li>
</ul></div>
</p></div>
</p></div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">Threads</h3>
<div class="outline-text-3" id="text-13-2">
<p> プログラムの処理の単位(Thread of Program) </p>
<ul class="org-ul">
<li>Each thread is sequential. </li>
<li>Each thread is independent of the others. </li>
<li>Two threads can communicate if they share a variable </li>
</ul>
<p> WikipediaではCPUのひとつの処理単位と定義されている。 </p>
<p> <a href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)">- スレッド (コンピュータ) - Wikipedia</a> </p>
</p></div>
</p></div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">Streams</h3>
<div class="outline-text-3" id="text-13-3">
<p> リストの終端がUnbound Variableであるもの。 </p>
<p> Streamsは2つのThread間の通信チャネルとして利用できる。 </p>
<p> Streamの構成要素は以下。 </p>
<ul class="org-ul">
<li>Producer ストリームのデータを生成。 </li>
<li>Consumer Producerから生成されたストリームのデータを受け取ってアクションを起こす。 </li>
<li>Transformer ProducerとConsumerとの間を仲介する。   </li>
<li>Pipeline ProducerとConsumerとTransformerの間を仲介する。   </li>
</ul>
<p> 単一格納変数(single-assined value)の性質（一度しか代入できない) を同期のスレッド間通信のための手段にする。 </p>
<p> 平行スレッドのなかでStreamを読み書きするものをAgentsという。 </p>
<div class="org-src-container">
<pre class="src src-language">  Produce ----------> Transformer --------> Consuemer
</pre>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">NonDeterminism</h3>
<div class="outline-text-3" id="text-13-4">
<p> 非決定性。プログラムの実行結果を決定ことができるシステムの能力。 </p>
<p> Nondeterminismはmanagedされることが必須！ しかし、制御がとても難しい。 だからこそ、Determinismが重要なのだと。 </p>
</p></div>
<div id="outline-container-sec-13-4-1" class="outline-4">
<h4 id="sec-13-4-1">Scheduler</h4>
<div class="outline-text-4" id="text-13-4-1">
<p> どのスレッドを実行するかを決める、システムの一部をスケジューラという。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5">Concurrency Transparency</h3>
<div class="outline-text-3" id="text-13-5">
<p> 平行透過性。 </p>
<p> 複数のユーザーが1つのリソースを共有して使用するとき、 それらユーザーに競合状態を気づかせてはならない。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E9%80%8F%E9%81%8E%E6%80%A7_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)">透過性 (情報工学) - Wikipedia</a> </li>
</ul></div>
<div id="outline-container-sec-13-5-1" class="outline-4">
<h4 id="sec-13-5-1">concurrency for dummies</h4>
<div class="outline-text-4" id="text-13-5-1">
<p> 平行性のためのダミースレッド。 </p>
<p> 平行透過性のためには、いくらスレッドを動的に追加しようとも、削除しようとも、 最終的に得られる結果はかわらない(Deterministic!) </p>
<p> それは、スレッドの各処理をincrementalに動作させることで可能となる  </p>
</p></div>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Multi-agent dataflow programmming</h2>
<div class="outline-text-2" id="text-14">
<p> マルチエジェーントデータフロープログラミング。 </p>
<p> Concurrency を解決するためのいろいろなパラダイムのなかで、 最強のパラダイムがこれだとピーターバンロイさんはいう。 </p>
<p> なぜなら、Deterministic Dataflow Programmingをベースに、 NonDeterminismの制御を機能追加したから。 </p>
<p> (Deterministic Dataflow Programmingに、Portという明示的状態をくわえた) </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%AB%E3%83%81%E3%82%A8%E3%83%BC%E3%82%B8%E3%82%A7%E3%83%B3%E3%83%88%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0">マルチエージェントシステム - Wikipedia</a> </li>
</ul>
<p> Distributed Systemともいう。 </p>
<p> CTMCP, Chapter 5 </p>
</p></div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">Port</h3>
<div class="outline-text-3" id="text-14-1">
<p> ボート。Named Steram.名前のつけられたストリーム。 </p>
<p> 以下の操作をもつ、Abstruct Data Structure。 </p>
<ul class="org-ul">
<li>Port Creation </li>
<li>Message Sending
<ul class="org-ul">
<li>Asyncronize </li>
<li>Syncronize </li>
</ul>
</li>
</ul></div>
</p></div>
<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">Agents</h3>
<div class="outline-text-3" id="text-14-2">
<p> 通信モデルは大きく2つに分けられる。 </p>
<ul class="org-ul">
<li>Client-Server Architectures </li>
<li>Pear-to-Pear Architectures </li>
</ul>
<p> Client,Server,PearをAgentという。 </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%A8%E3%83%BC%E3%82%B8%E3%82%A7%E3%83%B3%E3%83%88">ソフトウェアエージェント - Wikipedia</a> </li>
</ul>
<p> 以下の構成要素をもつ。 </p>
<ul class="org-ul">
<li>have identity     &#x2026; mail address </li>
<li>recieve messages  &#x2026; mailbox </li>
<li>process messeges  &#x2026; orderd mailbox </li>
<li>reply to messeges &#x2026; pre-addressed return letter </li>
</ul>
<p> エージェントは独立実体で、自身の局所的な目的を目指して仕事をする。 相互作用が適切に設計されていればエージェントは大局的仕事も達成する。 </p>
<p> CTMCP, Chapter 5より。 </p>
<p> Agentをもちいるプログラミングを、 Object-Oriented Programmingと対比されて、 Agent-Oriented Programmingということもある。 </p>
<p> ただし、Agentは必ずしもObjectでなくてもよい。2つのうちのどちらか。 </p>
<ul class="org-ul">
<li>Object </li>
<li>Transition state-functions </li>
</ul></div>
<div id="outline-container-sec-14-2-1" class="outline-4">
<h4 id="sec-14-2-1">Coordinator</h4>
<div class="outline-text-4" id="text-14-2-1">
<p> AgentのなかでほかのAgentをまとめるAgentをCoordinatorという。以下の性質をもつ。 </p>
<ul class="org-ul">
<li>代理性 ・・・他のAgentの代理をして処理をおこなう。処理の結果をAgentに通知。 </li>
<li>知性   ・・・ 他のAgentから情報をあつめを代表して判断を下す。 </li>
<li>移動性 ・・・他のAgentを代表して判断を下す。 </li>
</ul>
<p> Master(Coordinator)-Slave Archtecture. </p>
<ul class="org-ul">
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%82%B9%E3%83%AC%E3%83%BC%E3%83%96">マスタースレーブ - Wikipedia</a> </li>
</ul></div>
</p></div>
<div id="outline-container-sec-14-2-2" class="outline-4">
<h4 id="sec-14-2-2">Stateless Agent</h4>
<div class="outline-text-4" id="text-14-2-2">
<p> あるメッセージを受信したときに、そのメッセージに応じてアクションをとるAgents. アクションは受信メッセージに依存する。 </p>
<p> Agentはひとつのスレッドと複数のポートをもつ。ボートは明示的変数(Cell)と同義。 </p>
<p> このPort以外はImmutableなデータ構造。Portのみがメモリ上に確保される。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-14-2-3" class="outline-4">
<h4 id="sec-14-2-3">State with Agent</h4>
<div class="outline-text-4" id="text-14-2-3">
<p> ポートの他にState(明示的状態)をもつこともある。 </p>
<p> 処理の実行自体はStreamデータ構造に入ったfunctionのプロシージャごとに実施する (Immutable and incremental)が、StateによってReplyの方法を変える。 </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">Protocol</h3>
<div class="outline-text-3" id="text-14-3">
<p> Messageの送信と受信のルール。 </p>
<p> <a href="https://ja.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB">- 通信プロトコル - Wikipedia</a> </p>
<p> プロトコルにしたがうことで、デッドロックを防ぐ。 </p>
</p></div>
<div id="outline-container-sec-14-3-1" class="outline-4">
<h4 id="sec-14-3-1">BroadCast</h4>
<div class="outline-text-4" id="text-14-3-1">
<p> 他の複数のエージェント(Multi-Agent)に通信を送る。 </p>
</p></div>
</p></div>
<div id="outline-container-sec-14-3-2" class="outline-4">
<h4 id="sec-14-3-2">Contract Net</h4>
<div class="outline-text-4" id="text-14-3-2">
<p> 契約ネットプロトコル。 <a href="https://en.wikipedia.org/wiki/Contract_Net_Protocol">Contract Net Protocol - Wikipedia, the free encyclopedia</a> </p>
</p></div>
</p></div>
</p></div>
<div id="outline-container-sec-14-4" class="outline-3">
<h3 id="sec-14-4">Ozma</h3>
<div class="outline-text-3" id="text-14-4">
<p> Multi-agent dataflow programmmingを実現するための言語。ScalaとOzを合体させた。 </p>
<p> ピーターバンロイさん直々の説明動画は以下で見れる。 </p>
<ul class="org-ul">
<li><a href="https://www.infoq.com/presentations/Ozma-Extending-Scala-with-Oz-Concurrency">Ozma: Extending Scala with Oz Concurrency</a> </li>
</ul>
<p> github repository. </p>
<ul class="org-ul">
<li><a href="https://github.com/sjrd/ozma">sjrd/ozma</a> </li>
</ul></div>
</p></div>
</p></div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Active Objects Programming(Object-Based Agent)</h2>
<div class="outline-text-2" id="text-15">
<p> オブジェクト指向におけるオブジェクトを、 自ら判断し処理できる機能を持ったエージェントと呼ばれるモジュールに 置き換えたもの。 </p>
<p> Object-Oriented Programming とMulti-Agent Programmingの2つのパラダイムを 合体させてできたパラダイム。 </p>
<p> オブジェクトの属性ではなくて振る舞いが重要視される。 </p>
<ul class="org-ul">
<li><a href="https://itpro.nikkeibp.co.jp/word/page/10024992/">「エージェント指向」とは：ITpro</a> </li>
<li><a href="https://www.ogis-ri.co.jp/otc/hiroba/technical/agent/article/index.html">エージェント指向が目指すもの -INDEX-</a> </li>
</ul>
<p> EnglishのWikipediaに OOPとAOPの対応比較表がある。 </p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Agent-oriented_programming">https://en.wikipedia.org/wiki/Agent-oriented_programming</a> </li>
</ul></div>
</p></div>